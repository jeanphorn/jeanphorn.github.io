<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jeanphorn&#39;s Blog</title>
    <description> Jeanphorn，Linux programmer，Server Engineer，Big Data | 这里是 @Jeanphorn 的个人博客，Welcome to share the world.</description>
    <link>http://jeanphorn.github.io/</link>
    <atom:link href="http://jeanphorn.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 12 Nov 2015 10:58:28 +0800</pubDate>
    <lastBuildDate>Thu, 12 Nov 2015 10:58:28 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>谷歌第二代深度学习系统&quot;TensorFlow&quot;首解密</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;1. 背景&lt;/h1&gt;
&lt;p&gt;Google资深系统专家Jeff Dean在最近的湾区机器学习大会做了 Large-Scale Deep Learning for Inelligent Computer Systems 的演讲。&lt;/p&gt;

&lt;p&gt;“Over the past few years, we have built large-scale computer systems for training neural networks and then applied these systems to a wide variety of problems that have traditionally been very difficult for computers. We have made significant improvements in the state-of-the-art in many of these areas and our software systems and algorithms have been used by dozens of different groups at Google to train state-of-the-art models for speech recognition, image recognition, various visual detection tasks, language modeling, language translation, and many other tasks. In this talk, Google Senior Fellow Jeff Dean highlights some of the distributed systems and algorithms that Google uses in order to train large models quickly. He also discusses ways Google has applied this work to a variety of problems in its products, usually in close collaboration with other teams.&lt;/p&gt;

&lt;p&gt;Jeff Dean, senior fellow, Google Knowledge Group&lt;/p&gt;

&lt;p&gt;02/26/2015”&lt;/p&gt;

&lt;p&gt;【Jeff Dean】在过去的几年间，我们已经建立了两代用于训练和部署神经网络的计算机系统，并且将这些系统应用于解决很多在传统上来说对计算机而言很难的问题。我们对许多这些领域的最新技术做了很大的改进，我们的软件系统和算法已经被Google的很多小组采用，运用在语音识别、图像识别、视觉检测任务、语言建模、语言翻译和许多其它任务的模型训练上。&lt;strong&gt;在这次讲演中，我会介绍我们从第一代分布式训练系统中得到的经验教训，并讨论在设计第二代系统时的一些选择。&lt;/strong&gt;然后我会讨论一下我们将通过哪些方式把它运用到Google的大量产品上，在这方面通常我们会与其他小组有密切的合作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://vdisk.weibo.com/s/zTp6HtYlPosqi&quot;&gt;Google 资深专家Jeff Dean 关于深度学习 TensorFlow演讲视频：”Large-Scale Deep Learning for Building Intelligent Computer Systems.mp4”下载&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://vdisk.weibo.com/s/zTp6HtYlPosdP&quot;&gt;TensorFlow演讲稿 PDF版下载&lt;/a&gt;&lt;br /&gt;
# 2. 概述&lt;br /&gt;
第一代系统DistBeliet在可扩缩性上表现很好，但在用于研究时灵活性达不到预期。对问题空间的更深理解让我们可以做出一些大幅度的简化。&lt;/p&gt;

&lt;p&gt;这也是第二代系统的研发动机，用 TensorFlow 表达高层次的机器学习计算。它是C++语言编写的核心，冗余少。而不同的前端，现有Python和C++前端，添加其他语言的前端也不是难题。&lt;/p&gt;

&lt;p&gt;在2015年10月5日，谷歌为TensorFlow提交了注册商标申请（登记编号86778464），这样描述它：&lt;/p&gt;

&lt;p&gt;1.用以编写程序的计算机软件；&lt;/p&gt;

&lt;p&gt;2.计算机软件开发工具；&lt;/p&gt;

&lt;p&gt;3.可应用于人工智能、深度学习、高性能计算、分布式计算、虚拟化和机器学习这些领域；&lt;/p&gt;

&lt;p&gt;4.软件库可应用于通用目的的计算、数据收集的操作、数据变换、输入输出、通信、图像显示、人工智能等领域的建模和测试；&lt;/p&gt;

&lt;p&gt;5.软件可用作应用于人工智能等领域的应用程序接口（API）。&lt;/p&gt;

</description>
        <pubDate>Sat, 07 Nov 2015 02:30:00 +0800</pubDate>
        <link>http://jeanphorn.github.io/it%20information/2015/11/07/jeffdean-tensorflow/</link>
        <guid isPermaLink="true">http://jeanphorn.github.io/it%20information/2015/11/07/jeffdean-tensorflow/</guid>
        
        <category>deep learning</category>
        
        <category>深度学习</category>
        
        <category>TensorFlow</category>
        
        
        <category>IT information</category>
        
      </item>
    
      <item>
        <title>序列化和反序列化二叉树</title>
        <description>&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 描述&lt;/h2&gt;
&lt;p&gt;　　设计一个算法，实现二叉树的序列化与反序列化。如何实现没有限制，只要保证一颗二叉树可以序列化为一个string串，然后这个string串可以反序列化为原来的二叉树即可。详细描述如下：&lt;br /&gt;
　　&lt;img src=&quot;http://img.blog.csdn.net/20151030105003302?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;problem&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2. 方法与思路&lt;/h2&gt;
&lt;p&gt;　　采用先序遍历的思路，为了保证重构二叉树时，节点能够插入到数中的正确位置，空节点用“#”保存。为了保证从字符串中读取节点值方便，节点的值在字符串中用空格分开。重构时依旧安装先序的思想递归实现即可。&lt;br /&gt;
　　&lt;br /&gt;
　　序列化serialize：&lt;br /&gt;
　　&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;if (root = null) : str += “# “&lt;/li&gt;
  &lt;li&gt;递归&lt;br /&gt;
 str += root-&amp;gt;data+ “ “&lt;br /&gt;
 serialize(root-&amp;gt;left, str)&lt;br /&gt;
 serialize(root-&amp;gt;right, str)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　反序列化：&lt;/p&gt;

&lt;p&gt;1 .读字符串中一个节点的值&lt;br /&gt;
 2 . $if $ not Digit&lt;br /&gt;
	    　　$return$&lt;br /&gt;
3 . 是数字&lt;br /&gt;
	root = new TreeNode(val);&lt;br /&gt;
   递归重构左右子树。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Codec {
public: 
    void serialize(TreeNode* root, string &amp;amp;str) {
        if(!root) str += &quot;# &quot;;
        else {
            ostringstream oss;
            oss &amp;lt;&amp;lt; root-&amp;gt;val;
            str += oss.str() + &quot; &quot;;
            serialize(root-&amp;gt;left, str);
            serialize(root-&amp;gt;right,str);
        }   
    }   
    void deserialize(TreeNode *&amp;amp;root, string &amp;amp;str) {
        int val;
        //if(str.length()==0) return;
        string tmp = str.substr(0,str.find(&quot; &quot;)); 
        str = str.substr(str.find(&quot; &quot;)+1);
        if(atoi(tmp.c_str()) || tmp.compare(&quot;0&quot;) == 0) {
            val = atoi(tmp.c_str());
            root = new TreeNode(val); 
            deserialize(root-&amp;gt;left, str);
            deserialize(root-&amp;gt;right, str);
        }   
        else
        {   
            root = NULL;
            return ;
        }   
    }   
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string s=&quot;&quot;;
        serialize(root, s); 
        return s;
    }   

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        TreeNode *root = NULL;
        deserialize(root, data);
        return root;
    }   
};

&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 06 Nov 2015 04:50:00 +0800</pubDate>
        <link>http://jeanphorn.github.io/algorithm/2015/11/06/serialize-binary-tree/</link>
        <guid isPermaLink="true">http://jeanphorn.github.io/algorithm/2015/11/06/serialize-binary-tree/</guid>
        
        <category>二叉树</category>
        
        <category>序列化</category>
        
        <category>反序列化</category>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>Linux 静态和动态链接库的使用 dlopen()加载动态库文件</title>
        <description>&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;1.  静态链接库&lt;/h2&gt;
&lt;p&gt;　　静态库是obj文件的集合，一般以“.a”为后缀。静态库的有点事可以不用重新编译源程序，直接进行程序的重新链接，节省编译时间。开发者可以提供库文件而不用开放源代码。&lt;br /&gt;
　　命令：&lt;br /&gt;
　　&lt;code&gt;$ar -rcs obj文件1 obj文件2&lt;/code&gt;&lt;br /&gt;
　　例如我们编写一个string.cc的文件，里面定义了一个求字符串长度的函数。&lt;br /&gt;
　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define END &#39;\0&#39;

int my_strlen(char *str)
{
    int len = 0;
    while( *str++ != END)
    {   
        len ++; 
    }   
    return len;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　用如下命令生产静态库文件：&lt;br /&gt;
　　&lt;br /&gt;
    &lt;code&gt;
　　$ c++ -c string.cc
　　$ ar -rcs libstr.a string.o 
   &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　编写一个测试文件test.cc，内容如下：&lt;br /&gt;
　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

extern int my_strlen(char *str);

int main()
{
    char str[] = &quot;hello, jeanphorn!&quot;;
    printf(&quot;%d\n&quot;, my_strlen(str));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　编译命令： &lt;code&gt;c++ -o test test.cc libstr.a&lt;/code&gt;或者&lt;code&gt;c++ -o test test.cc -L./ -lstr&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2. 生成和使用动态链接库&lt;/h2&gt;
&lt;p&gt;　　动态链接库是程序运行时加载。生成动态链接库使用”-fpic”选项，例如：&lt;code&gt;c++ -shared -fpic -o libstr.so string.cc&lt;/code&gt;。动态库不能随意使用，需要在程序运行时制定系统的动态库搜素路径，让系统找到所需要的动态库。系统的配置文件”/etc/ld.so.conf”是动态库的搜索路径配置文件。&lt;br /&gt;
　　动态库管理命令ldconfig。&lt;br /&gt;
　　ldconfig的作用是在系统默认搜索路径和动态链接库配置文件和中所列出的目录里搜索动态库，创建动态链接装入程序需要的链接和缓存文件。搜索完毕后将结果写入到缓存文件/etc/ld.so.cache中。&lt;/p&gt;

&lt;p&gt;　　使用动态链接库。&lt;br /&gt;
　　编译程序时使用动态库和使用静态库是一致的，使用”-l库名”的方式。&lt;br /&gt;
　　&lt;code&gt;c++ -o test test.cc -L./ -lstr&lt;/code&gt;&lt;br /&gt;
　　但是要想正确运行test程序，还需要一步：将动态库文件放到程序搜素路径中。可以将libstr.so文件拷贝到/usr/lib等系统库路径中或者使用类似于下面这条命令：&lt;br /&gt;
	　&lt;code&gt;export LD_LIBRARY_PATH=/home/***/test/linux_network_program/lib_test&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3. 加载动态库&lt;/h2&gt;
&lt;p&gt;　　动态加载库主要的函数有dlopen(), dlerror(), dlsym()和dlclose()。&lt;br /&gt;
　　dlopen()，按照用户指定的方式打开动态库。原型：&lt;code&gt;void * dlopen(const char * filename, int flag)&lt;/code&gt;。 filename为动态库的名，flag打开方式，一般为“RTLD_LASY”。函数返回值为库的指针。&lt;br /&gt;
　　dlsym()获取函数指针。&lt;br /&gt;
　　例子：&lt;br /&gt;
　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dlfcn.h&amp;gt;

typedef int (*My_strlen)(char *str);

int main()
{
    char str[] = &quot;hello, jeanphorn!&quot;;
    void *phandle = NULL;


    phandle = dlopen(&quot;./libstr.so&quot;, RTLD_LAZY);
    if(!phandle) 
        printf(&quot;Load library failed.\n&quot;);
    
    char *perr = dlerror();
    if(perr != NULL)
    {   
        printf(&quot;%s\n&quot;,perr);
        return 0;
    }   

    My_strlen my_strlen = (My_strlen)dlsym(phandle, &quot;my_strlen&quot;);
    
    perr = dlerror();
    if(perr != NULL)
    {   
        printf(&quot;%s\n&quot;,perr);
        return 0;
    }   
    printf(&quot;%d\n&quot;, my_strlen(str));

    dlclose(phandle);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　编译: &lt;code&gt;c++ -o loadso loadso.cc libstr.so -ldl&lt;/code&gt;&lt;br /&gt;
　　编译后直接运行是不行的，因为dlsym()函数是c语言函数形式。在底层编译器gcc和c++编译情况是不同的。在string.cc文件上做如下改动：&lt;br /&gt;
　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define END &#39;\0&#39;

#ifdef __cplusplus
extern &quot;C&quot;{
#endif

int my_strlen(char *str)
{
    int len = 0;
    while( *str++ != END)
    {   
        len ++; 
    }   
    return len;
}

#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　重新编译生产so库就好了。&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://jeanphorn.github.io/linux/2015/11/04/linux-make-so/</link>
        <guid isPermaLink="true">http://jeanphorn.github.io/linux/2015/11/04/linux-make-so/</guid>
        
        <category>Linux</category>
        
        <category>dlopen</category>
        
        <category>dlsys</category>
        
        <category>静态链接库</category>
        
        <category>动态链接库</category>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
